// Copyright (c) 2022, Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

#[test_only]
module sui::crypto_tests {
    use sui::crypto;
    use sui::elliptic_curve as ec;
    #[test]
    fun test_ecrecover_pubkey() {
        // test case generated against https://docs.rs/secp256k1/latest/secp256k1/
        let hashed_msg = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];
        let sig = vector[132, 220, 128, 67, 151, 154, 45, 143, 50, 56, 176, 134, 137, 58, 223, 166, 191, 230, 178, 184, 123, 11, 19, 69, 59, 205, 72, 206, 153, 187, 184, 7, 16, 74, 73, 45, 38, 238, 81, 96, 138, 225, 235, 143, 95, 142, 185, 56, 99, 3, 97, 27, 66, 99, 79, 225, 139, 21, 67, 254, 78, 251, 176, 176, 0];
        let pubkey_bytes = vector[2, 2, 87, 224, 47, 124, 255, 117, 223, 91, 188, 190, 151, 23, 241, 173, 148, 107, 20, 103, 63, 155, 108, 151, 251, 152, 205, 205, 239, 71, 224, 86, 9];

        let pubkey = crypto::ecrecover(sig, hashed_msg);
        assert!(pubkey == pubkey_bytes, 0);
    }

    #[test]
    #[expected_failure(abort_code = 0)]
    fun test_ecrecover_pubkey_fail_to_recover() {
        let hashed_msg = vector[0];
        let sig = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        crypto::ecrecover(sig, hashed_msg);
    }

    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_ecrecover_pubkey_invalid_sig() {
        let hashed_msg = vector[0];
        // incorrect length sig
        let sig = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        crypto::ecrecover(sig, hashed_msg);
    }

    #[test]
    fun test_keccak256_hash() {
        let msg = b"hello world!";
        let hashed_msg_bytes = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];

        let hashed_msg = crypto::keccak256(msg);
        assert!(hashed_msg == hashed_msg_bytes, 0);
    }
    
    #[test]
    fun test_bls12381_valid_sig() {
        let msg = vector[1, 1, 1, 1, 1];
        let pk = vector[141, 241, 1, 96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 95, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == true, 0)
    }

    #[test]
    fun test_bls12381_invalid_sig() {
        let msg = vector[2, 1, 1, 1, 1];
        let pk = vector[141, 241, 1, 96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 95, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_bls12381_invalid_signature_key_length() {
        let msg = vector[2, 1, 1, 1, 1];
        let pk = vector[96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 0, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_bls12381_invalid_public_key_length() {
        let msg = vector[2, 1, 1, 1, 1];
        let pk = vector[96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 95, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_ristretto_point_addition() {
        let committed_value_1 = 1000u64;
        let blinding_value_1 = 100u64;
        let committed_value_2 = 500u64;
        let blinding_value_2 = 200u64;

        let committed_sum = committed_value_1 + committed_value_2;
        let blinding_sum = blinding_value_1 + blinding_value_2;

        let point_1 = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value_1),
            ec::new_scalar_from_u64(blinding_value_1)
        );

        let point_2 = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value_2),
            ec::new_scalar_from_u64(blinding_value_2)
        );

        let point_sum_reference = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_sum),
            ec::new_scalar_from_u64(blinding_sum)
        );

        let point_sum = ec::add(&point_1, &point_2);

        assert!(ec::bytes(&point_sum) == ec::bytes(&point_sum_reference), 0)
    }

    #[test]
    fun test_ristretto_point_subtraction() {
        let committed_value_1 = 1000u64;
        let blinding_value_1 = 100u64;
        let committed_value_2 = 500u64;
        let blinding_value_2 = 50u64;

        let committed_diff = committed_value_1 - committed_value_2;
        let blinding_diff = blinding_value_1 - blinding_value_2;

        let point_1 = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value_1),
            ec::new_scalar_from_u64(blinding_value_1)
        );

        let point_2 = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value_2),
            ec::new_scalar_from_u64(blinding_value_2)
        );

        let point_diff_reference = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_diff),
            ec::new_scalar_from_u64(blinding_diff)
        );

        let point_diff = ec::subtract(&point_1, &point_2);

        assert!(ec::bytes(&point_diff) == ec::bytes(&point_diff_reference), 0)
    }

    #[test]
    fun test_pedersen_commitment() {
        // These are generated elsewhere;
        let commitment = vector[224, 131, 28, 42, 140, 170, 172, 201, 243, 54, 153, 119, 106, 97, 215, 123, 64, 125, 6, 93, 9, 1, 78, 186, 6, 18, 64, 219, 210, 225, 125, 113];

        let committed_value = 1000u64;
        let blinding_factor = 10u64;

        let point = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value),
            ec::new_scalar_from_u64(blinding_factor)
        );

        assert!(commitment == ec::bytes(&point), 0);
    }

    #[test]
    fun test_bulletproof_standard_0_2pow64_proof() {
        let bit_length: u64 = 64;

        // These are generated elsewhere;
        let bulletproof = vector[
            134, 202, 56, 10, 230, 57, 155, 136, 64, 241, 33, 239, 133, 26, 63, 138, 65, 126, 109, 92, 239, 105, 128, 173, 28, 250, 214, 18, 209, 189, 46, 40, 166, 22, 208, 81, 154, 96, 78, 3, 238, 160, 30, 110, 30, 129, 58, 0, 225, 200, 118, 71, 228, 190, 191, 60, 102, 39, 185, 55, 18, 188, 113, 101, 8, 66, 68, 32, 67, 166, 124, 160, 1, 130, 124, 19, 181, 195, 67, 181, 140, 7, 56, 135, 242, 195, 60, 93, 6, 189, 95, 185, 39, 176, 180, 3, 234, 220, 117, 89, 165, 181, 100, 130, 229, 49, 108, 73, 244, 88, 251, 252, 86, 217, 113, 246, 244, 54, 195, 209, 206, 142, 201, 223, 240, 218, 166, 68, 186, 69, 147, 75, 84, 92, 44, 10, 79, 92, 207, 222, 129, 182, 157, 37, 117, 227, 233, 39, 125, 109, 90, 62, 79, 240, 167, 158, 123, 239, 31, 5, 43, 34, 136, 24, 26, 166, 58, 127, 203, 154, 27, 55, 234, 105, 16, 58, 140, 116, 45, 72, 98, 98, 105, 33, 46, 49, 81, 243, 211, 14, 241, 0, 1, 194, 207, 205, 205, 86, 35, 36, 33, 150, 50, 65, 62, 51, 11, 133, 60, 19, 68, 189, 46, 40, 185, 109, 179, 113, 84, 164, 191, 87, 57, 8, 226, 207, 49, 179, 235, 40, 255, 251, 147, 5, 64, 57, 109, 2, 217, 0, 83, 244, 123, 121, 14, 25, 152, 31, 138, 102, 113, 126, 137, 14, 231, 81, 212, 103, 120, 11, 136, 169, 75, 53, 210, 156, 72, 78, 116, 56, 150, 90, 141, 216, 71, 185, 130, 205, 235, 248, 131, 62, 191, 242, 216, 244, 47, 54, 166, 44, 212, 114, 252, 102, 136, 95, 140, 77, 128, 136, 163, 110, 194, 85, 41, 10, 241, 156, 236, 50, 144, 11, 191, 5, 225, 46, 121, 252, 163, 60, 206, 206, 160, 172, 234, 205, 30, 230, 177, 173, 103, 173, 3, 201, 170, 244, 218, 108, 232, 112, 68, 188, 21, 95, 193, 6, 86, 41, 13, 55, 58, 24, 118, 28, 145, 198, 185, 241, 241, 184, 177, 39, 224, 149, 171, 194, 130, 10, 104, 236, 178, 8, 172, 191, 118, 143, 121, 56, 46, 158, 35, 17, 159, 24, 28, 59, 68, 3, 221, 52, 34, 241, 168, 246, 234, 122, 244, 29, 87, 71, 222, 142, 44, 160, 164, 30, 199, 10, 247, 99, 90, 149, 72, 77, 214, 45, 42, 255, 15, 255, 76, 45, 163, 113, 163, 181, 101, 248, 248, 101, 10, 247, 6, 164, 201, 191, 22, 230, 151, 96, 146, 188, 79, 33, 243, 244, 15, 56, 74, 205, 186, 42, 97, 113, 151, 82, 115, 132, 202, 19, 32, 146, 209, 112, 215, 174, 41, 110, 190, 1, 123, 152, 161, 106, 55, 214, 114, 46, 163, 18, 138, 49, 204, 124, 39, 42, 124, 146, 138, 231, 101, 232, 152, 45, 101, 58, 119, 58, 220, 214, 229, 169, 169, 23, 231, 18, 175, 78, 230, 32, 95, 110, 90, 142, 165, 249, 20, 179, 57, 117, 217, 212, 11, 152, 47, 62, 64, 158, 72, 76, 201, 59, 51, 64, 245, 94, 69, 187, 41, 130, 177, 196, 14, 104, 72, 27, 186, 6, 10, 196, 203, 204, 20, 14, 113, 142, 46, 115, 76, 117, 157, 191, 89, 219, 169, 50, 83, 34, 244, 75, 199, 4, 160, 77, 22, 117, 118, 161, 188, 34, 60, 212, 72, 187, 223, 245, 226, 252, 79, 214, 83, 161, 35, 52, 32, 169, 21, 115, 151, 213, 170, 132, 71, 175, 99, 43, 129, 97, 226, 27, 238, 168, 206, 117, 39, 237, 192, 90, 107, 178, 184, 105, 68, 54, 90, 78, 197, 1, 87, 191, 212, 156, 195, 135, 153, 165, 247, 111, 113, 0, 187, 80, 255, 162, 188, 107, 200, 250, 91, 160, 165, 22, 142, 222, 15, 126, 147, 234, 230, 129, 41, 145, 103, 190, 78, 101, 75, 8, 75, 50, 89, 5
        ];

        let committed_value = 1000u64;
        let blinding_factor = 100u64;

        let point = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value),
            ec::new_scalar_from_u64(blinding_factor)
        );

        crypto::verify_full_range_proof(bulletproof, point, bit_length);
    }

    #[test]
    #[expected_failure(abort_code = 5)]
    fun test_bulletproof_standard_0_2pow64_invalid_proof() {
        let bit_length: u64 = 64;

        // These are generated elsewhere;
        let bulletproof = vector[
            0, 202, 56, 10, 230, 57, 155, 136, 64, 241, 33, 239, 133, 26, 63, 138, 65, 126, 109, 92, 239, 105, 128, 173, 28, 250, 214, 18, 209, 189, 46, 40, 166, 22, 208, 81, 154, 96, 78, 3, 238, 160, 30, 110, 30, 129, 58, 0, 225, 200, 118, 71, 228, 190, 191, 60, 102, 39, 185, 55, 18, 188, 113, 101, 8, 66, 68, 32, 67, 166, 124, 160, 1, 130, 124, 19, 181, 195, 67, 181, 140, 7, 56, 135, 242, 195, 60, 93, 6, 189, 95, 185, 39, 176, 180, 3, 234, 220, 117, 89, 165, 181, 100, 130, 229, 49, 108, 73, 244, 88, 251, 252, 86, 217, 113, 246, 244, 54, 195, 209, 206, 142, 201, 223, 240, 218, 166, 68, 186, 69, 147, 75, 84, 92, 44, 10, 79, 92, 207, 222, 129, 182, 157, 37, 117, 227, 233, 39, 125, 109, 90, 62, 79, 240, 167, 158, 123, 239, 31, 5, 43, 34, 136, 24, 26, 166, 58, 127, 203, 154, 27, 55, 234, 105, 16, 58, 140, 116, 45, 72, 98, 98, 105, 33, 46, 49, 81, 243, 211, 14, 241, 0, 1, 194, 207, 205, 205, 86, 35, 36, 33, 150, 50, 65, 62, 51, 11, 133, 60, 19, 68, 189, 46, 40, 185, 109, 179, 113, 84, 164, 191, 87, 57, 8, 226, 207, 49, 179, 235, 40, 255, 251, 147, 5, 64, 57, 109, 2, 217, 0, 83, 244, 123, 121, 14, 25, 152, 31, 138, 102, 113, 126, 137, 14, 231, 81, 212, 103, 120, 11, 136, 169, 75, 53, 210, 156, 72, 78, 116, 56, 150, 90, 141, 216, 71, 185, 130, 205, 235, 248, 131, 62, 191, 242, 216, 244, 47, 54, 166, 44, 212, 114, 252, 102, 136, 95, 140, 77, 128, 136, 163, 110, 194, 85, 41, 10, 241, 156, 236, 50, 144, 11, 191, 5, 225, 46, 121, 252, 163, 60, 206, 206, 160, 172, 234, 205, 30, 230, 177, 173, 103, 173, 3, 201, 170, 244, 218, 108, 232, 112, 68, 188, 21, 95, 193, 6, 86, 41, 13, 55, 58, 24, 118, 28, 145, 198, 185, 241, 241, 184, 177, 39, 224, 149, 171, 194, 130, 10, 104, 236, 178, 8, 172, 191, 118, 143, 121, 56, 46, 158, 35, 17, 159, 24, 28, 59, 68, 3, 221, 52, 34, 241, 168, 246, 234, 122, 244, 29, 87, 71, 222, 142, 44, 160, 164, 30, 199, 10, 247, 99, 90, 149, 72, 77, 214, 45, 42, 255, 15, 255, 76, 45, 163, 113, 163, 181, 101, 248, 248, 101, 10, 247, 6, 164, 201, 191, 22, 230, 151, 96, 146, 188, 79, 33, 243, 244, 15, 56, 74, 205, 186, 42, 97, 113, 151, 82, 115, 132, 202, 19, 32, 146, 209, 112, 215, 174, 41, 110, 190, 1, 123, 152, 161, 106, 55, 214, 114, 46, 163, 18, 138, 49, 204, 124, 39, 42, 124, 146, 138, 231, 101, 232, 152, 45, 101, 58, 119, 58, 220, 214, 229, 169, 169, 23, 231, 18, 175, 78, 230, 32, 95, 110, 90, 142, 165, 249, 20, 179, 57, 117, 217, 212, 11, 152, 47, 62, 64, 158, 72, 76, 201, 59, 51, 64, 245, 94, 69, 187, 41, 130, 177, 196, 14, 104, 72, 27, 186, 6, 10, 196, 203, 204, 20, 14, 113, 142, 46, 115, 76, 117, 157, 191, 89, 219, 169, 50, 83, 34, 244, 75, 199, 4, 160, 77, 22, 117, 118, 161, 188, 34, 60, 212, 72, 187, 223, 245, 226, 252, 79, 214, 83, 161, 35, 52, 32, 169, 21, 115, 151, 213, 170, 132, 71, 175, 99, 43, 129, 97, 226, 27, 238, 168, 206, 117, 39, 237, 192, 90, 107, 178, 184, 105, 68, 54, 90, 78, 197, 1, 87, 191, 212, 156, 195, 135, 153, 165, 247, 111, 113, 0, 187, 80, 255, 162, 188, 107, 200, 250, 91, 160, 165, 22, 142, 222, 15, 126, 147, 234, 230, 129, 41, 145, 103, 190, 78, 101, 75, 8, 75, 50, 89, 5
        ];

        let committed_value = 1000u64;
        let blinding_factor = 100u64;

        let point = ec::create_pedersen_commitment(
            ec::new_scalar_from_u64(committed_value),
            ec::new_scalar_from_u64(blinding_factor)
        );

        crypto::verify_full_range_proof(bulletproof, point, bit_length);
    }

    #[test]
    fun test_secp256k1_valid_sig() {
        let msg = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];
        let pk = vector[2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152];
        let sig = vector[156, 122, 114, 255, 30, 125, 177, 100, 107, 159, 148, 67, 203, 26, 53, 99, 170, 58, 99, 68, 228, 229, 19, 239, 185, 98, 88, 199, 103, 106, 196, 137, 89, 83, 98, 157, 64, 154, 131, 36, 114, 183, 16, 160, 40, 40, 93, 254, 196, 115, 58, 44, 27, 176, 162, 116, 158, 70, 90, 24, 41, 43, 139, 214, 1];
        let verify = crypto::secp256k1_verify(sig, pk, msg);
        assert!(verify == true, 0)
    }

    #[test]
    fun test_secp256k1_invalid_sig() {
        let msg = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];
        let pk = vector[2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152];
        // sig in the form of (r, s, 0) instead of (r, s, 1)
        let sig = vector[156, 122, 114, 255, 30, 125, 177, 100, 107, 159, 148, 67, 203, 26, 53, 99, 170, 58, 99, 68, 228, 229, 19, 239, 185, 98, 88, 199, 103, 106, 196, 137, 89, 83, 98, 157, 64, 154, 131, 36, 114, 183, 16, 160, 40, 40, 93, 254, 196, 115, 58, 44, 27, 176, 162, 116, 158, 70, 90, 24, 41, 43, 139, 214, 0];
        let verify = crypto::secp256k1_verify(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_secp256k1_invalid_sig_length() {
        let msg = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];
        let pk = vector[2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152];
        let sig = vector[156, 122, 114, 255, 30, 125, 177, 100, 107, 159, 148, 67, 203, 26, 53, 99, 170, 58, 99, 68, 228, 229, 19, 239, 185, 98, 88, 199, 103, 106, 196, 137, 89, 83, 98, 157, 64, 154, 131, 36, 114, 183, 16, 160, 40, 40, 93, 254, 196, 115, 58, 44, 27, 176, 162, 116, 158, 70, 90, 24, 41, 43, 139, 214];
        let verify = crypto::secp256k1_verify(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_secp256k1_invalid_hashed_msg_length() {
        let msg = vector[1];
        let pk = vector[2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152];
        let sig = vector[156, 122, 114, 255, 30, 125, 177, 100, 107, 159, 148, 67, 203, 26, 53, 99, 170, 58, 99, 68, 228, 229, 19, 239, 185, 98, 88, 199, 103, 106, 196, 137, 89, 83, 98, 157, 64, 154, 131, 36, 114, 183, 16, 160, 40, 40, 93, 254, 196, 115, 58, 44, 27, 176, 162, 116, 158, 70, 90, 24, 41, 43, 139, 214];
        let verify = crypto::secp256k1_verify(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_secp256k1_invalid_public_key_length() {
        let msg = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];
        let pk = vector[121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152];
        let sig = vector[156, 122, 114, 255, 30, 125, 177, 100, 107, 159, 148, 67, 203, 26, 53, 99, 170, 58, 99, 68, 228, 229, 19, 239, 185, 98, 88, 199, 103, 106, 196, 137, 89, 83, 98, 157, 64, 154, 131, 36, 114, 183, 16, 160, 40, 40, 93, 254, 196, 115, 58, 44, 27, 176, 162, 116, 158, 70, 90, 24, 41, 43, 139, 214, 1];
        let verify = crypto::secp256k1_verify(sig, pk, msg);
        assert!(verify == false, 0)
    }
}
