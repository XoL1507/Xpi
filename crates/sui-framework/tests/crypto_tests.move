// Copyright (c) 2022, Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

#[test_only]
module sui::crypto_tests {
    use sui::crypto;
    #[test]
    fun test_ecrecover_pubkey() {
        // test case generated against https://docs.rs/secp256k1/latest/secp256k1/
        let hashed_msg = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];
        let sig = vector[132, 220, 128, 67, 151, 154, 45, 143, 50, 56, 176, 134, 137, 58, 223, 166, 191, 230, 178, 184, 123, 11, 19, 69, 59, 205, 72, 206, 153, 187, 184, 7, 16, 74, 73, 45, 38, 238, 81, 96, 138, 225, 235, 143, 95, 142, 185, 56, 99, 3, 97, 27, 66, 99, 79, 225, 139, 21, 67, 254, 78, 251, 176, 176, 0];
        let pubkey_bytes = vector[2, 2, 87, 224, 47, 124, 255, 117, 223, 91, 188, 190, 151, 23, 241, 173, 148, 107, 20, 103, 63, 155, 108, 151, 251, 152, 205, 205, 239, 71, 224, 86, 9];

        let pubkey = crypto::ecrecover(sig, hashed_msg);
        assert!(pubkey == pubkey_bytes, 0);
    }

    #[test]
    #[expected_failure(abort_code = 0)]
    fun test_ecrecover_pubkey_fail_to_recover() {
        let hashed_msg = vector[0];
        let sig = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        crypto::ecrecover(sig, hashed_msg);
    }

    #[test]
    #[expected_failure(abort_code = 1)]
    fun test_ecrecover_pubkey_invalid_sig() {
        let hashed_msg = vector[0];
        // incorrect length sig
        let sig = vector[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        crypto::ecrecover(sig, hashed_msg);
    }

    #[test]
    fun test_keccak256_hash() {
        let msg = b"hello world!";
        let hashed_msg_bytes = vector[87, 202, 161, 118, 175, 26, 192, 67, 60, 93, 243, 14, 141, 171, 205, 46, 193, 175, 30, 146, 162, 110, 206, 213, 247, 25, 184, 132, 88, 119, 124, 214];

        let hashed_msg = crypto::keccak256(msg);
        assert!(hashed_msg == hashed_msg_bytes, 0);
    }
    
    #[test]
    fun test_bls12381_valid_sig() {
        let msg = vector[1, 1, 1, 1, 1];
        let pk = vector[141, 241, 1, 96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 95, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == true, 0)
    }

    #[test]
    fun test_bls12381_invalid_sig() {
        let msg = vector[2, 1, 1, 1, 1];
        let pk = vector[141, 241, 1, 96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 95, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_bls12381_invalid_signature_key_length() {
        let msg = vector[2, 1, 1, 1, 1];
        let pk = vector[96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 0, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == false, 0)
    }

    #[test]
    fun test_bls12381_invalid_public_key_length() {
        let msg = vector[2, 1, 1, 1, 1];
        let pk = vector[96, 111, 145, 243, 202, 215, 245, 75, 138, 255, 15, 15, 100, 196, 28, 72, 45, 155, 159, 159, 232, 29, 43, 96, 123, 197, 246, 17, 189, 250, 128, 23, 207, 4, 180, 123, 68, 178, 34, 195, 86, 239, 85, 95, 189, 17, 5, 140, 82, 192, 119, 245, 167, 236, 106, 21, 204, 253, 99, 159, 220, 155, 212, 125, 0, 90, 17, 29, 214, 205, 184, 192, 47, 228, 150, 8, 223, 85, 163, 201, 130, 41, 134, 173, 11, 134, 189, 234, 58, 191, 223, 228, 100];
        let sig = vector[144, 142, 52, 95, 46, 40, 3, 205, 148, 26, 232, 140, 33, 140, 150, 25, 66, 51, 201, 5, 63, 161, 188, 165, 33, 36, 120, 125, 60, 202, 20, 28, 54, 66, 157, 118, 82, 67, 90, 130, 12, 114, 153, 45, 94, 238, 99, 23];
        let verify = crypto::bls12381_verify_g1_sig(sig, pk, msg);
        assert!(verify == false, 0)
    }
}
